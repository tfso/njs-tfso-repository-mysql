{"version":3,"file":"queryrecordset.js","sourceRoot":"","sources":["../../src/db/queryrecordset.ts"],"names":[],"mappings":"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","sourcesContent":["import * as MySql from 'mysql';\nimport { Query } from 'tfso-repository/lib/repository/db/query';\nimport { IRecordSet, RecordSet } from 'tfso-repository/lib/repository/db/recordset';\n\nimport { WhereOperator } from 'tfso-repository/lib/linq/operators/whereoperator';\nimport { SkipOperator } from 'tfso-repository/lib/linq/operators/skipoperator';\nimport { TakeOperator } from 'tfso-repository/lib/linq/operators/takeoperator';\n\nexport abstract class QueryRecordSet<TEntity> extends Query<TEntity> {\n    private _connection: MySql.Connection;\n\n    constructor(connection?: MySql.Connection) {\n        super();\n\n        if (connection != null)\n            this._connection = connection;\n    }\n\n    public set connection(connection: MySql.Connection) {\n        this._connection = connection;\n    }\n\n    protected input(name: string, value: any): void\n    protected input(name: string, type: any, value: any): void\n    protected input(name: string, type: any, value?: any): void {\n        if (arguments.length == 2) {\n            value = type; type = null;\n        }\n\n        this.parameters[name] = { name: name, type: type, value: value };\n    }\n\n    protected executeQuery(): Promise<IRecordSet<TEntity>> {\n        return new Promise((resolve, reject) => {\n            try {\n                let timed = Date.now(),\n                    totalRecords = -1,\n                    totalPredicateIterations: number = 0,\n                    parameters = {};\n\n                for (let key in this.parameters) {\n                    let param = this.parameters[key];\n\n                    parameters[param.name] = param.value;\n                }\n\n                this._connection.query(this.commandText, parameters, (err, result, fields) => {\n                    if (err)\n                        return reject(err);\n\n                    try {\n                        let results: Array<any> = [],\n                            recordset: Array<any>,\n                            affectedRecords: number = 0,\n                            changedRecords: number = 0;\n\n                        // well, MySql library returns either multiple recordsets or a single recordset, and we really want multiple recordsets\n                        if (Array.isArray(result) && result[0].constructor.name == 'RowDataPacket')\n                            recordset = [result];\n                        else\n                            recordset = [].concat(result);\n\n                        for (let i = 0; i < recordset.length; i++) {\n\n                            switch (recordset[i].constructor.name) {\n                                case 'OkPacket':\n                                    affectedRecords = (<MySql.OkPacket>recordset[i]).affectedRows;\n                                    changedRecords = (<MySql.OkPacket>recordset[i]).changedRows;\n\n                                    break;\n\n                                default:\n                                    // go through each recordst and check for totalRecords\n                                    if (totalRecords == -1) {\n                                        let row: any = null;\n\n                                        if (Array.isArray(recordset[i]) && recordset[i].length > 0)\n                                            row = recordset[i][0];\n\n                                        if (row) {\n                                            if (row['pagingTotalCount'] && isNaN(row['pagingTotalCount']) == false) {\n                                                totalRecords = Number(row['pagingTotalCount'])\n                                            }\n                                        }\n                                    }\n\n                                    results = recordset[i];\n\n                                    break;\n                            }\n                        }\n\n                        // should really validate this.query to see if operators Where, Skip, Take, OrderBy etc comes in correct order otherwhise it's not supported for this kind of database\n                        let where = this.query.operations.first(WhereOperator),\n                            predicate: (entity: TEntity) => boolean,\n                            entities: Array<TEntity>;\n\n                        if (where) {\n                            this.query.operations.remove(where);\n\n                            predicate = ((op: WhereOperator<TEntity>) => {\n                                return (entity: TEntity) => {\n                                    return op.predicate.apply({}, [entity].concat(op.parameters));\n                                }\n                            })(<WhereOperator<TEntity>>where);\n                        }\n\n                        entities = results.map(this.transform);\n                        if (predicate) {\n                            entities = entities.filter(predicate);\n\n                            if (this.query.operations.first(SkipOperator) || this.query.operations.first(TakeOperator))\n                                totalRecords = entities.length;\n                        }\n\n                        resolve(new RecordSet(\n                            result ? this.query.toArray(entities) : [],\n                            changedRecords || affectedRecords,\n                            Date.now() - timed,\n                            totalRecords >= 0 ? totalRecords : undefined)\n                        );\n                    }\n                    catch (ex) {\n                        reject(ex);\n                    }\n                });\n            }\n            catch (ex) {\n                reject(ex);\n            }\n        })\n    }\n\n    protected abstract transform(record: any): TEntity;\n}\n\nexport default QueryRecordSet\n\nexport { RecordSet }"]}