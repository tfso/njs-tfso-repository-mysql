{"version":3,"file":"connection.js","sourceRoot":"","sources":["../../src/db/connection.ts"],"names":[],"mappings":";;AAAA,+BAA+B;AAC/B,+BAAiC;AAQjC;IAGI,YAAY,gBAA8E;QACtF,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC;IAC/D,CAAC;IAEM,gBAAgB;QACnB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;IACxD,CAAC;IAEM,iBAAiB;QACpB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;IACxD,CAAC;IAEM,mBAAmB;QACtB,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC,CAAC;IACxD,CAAC;IAKM,KAAK,CAAC,OAAO,CAAI,UAAe;QACnC,IAAI,gBAAgB,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAC/C,UAA4B,CAAC;QAEjC,gBAAgB,CAAC,kBAAkB,GAAG,IAAI,CAAC;QAE3C,UAAU,GAAG,KAAK,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,CAAC;QACtD,UAAU,CAAC,MAAM,CAAC,WAAW,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE;YAC9C,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;gBAAC,MAAM,CAAC,KAAK,CAAC;YAE1B,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;gBAC1C,EAAE,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC1C,CAAC;gBACD,MAAM,CAAC,GAAG,CAAC;YACf,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QAEF,MAAM,gBAAS,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC;QAEvD,IAAI,OAA+B,CAAC;QACpC,EAAE,CAAC,CAAC,OAAO,UAAU,IAAI,UAAU,CAAC,CAAC,CAAC;YAClC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;QACtD,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,UAAU,CAAC,UAAU,GAAG,UAAU,CAAC;YACnC,OAAO,GAAG,UAAU,CAAC;QACzB,CAAC;QAED,wFAAwF;QACxF,IAAI,SAAS,GAAG,MAAM,OAAO,CAAC;QAE9B,8EAA8E;QAC9E,mJAAmJ;QACnJ,UAAU,CAAC,GAAG,EAAE,CAAC;QAEjB,MAAM,CAAC,SAAS,CAAC;IACrB,CAAC;CAkBJ;AA5ED,6BA4EC","sourcesContent":["import * as MySql from 'mysql';\nimport { promisify } from 'util';\n\nimport { Query } from 'tfso-repository/lib/repository/db/query';\nimport { IRecordSet, RecordSet } from 'tfso-repository/lib/repository/db/recordset';\n\nimport { QueryRecordSet } from './queryrecordset';\nimport { QueryStream } from './querystream';\n\nexport default class Connection {\n    private _connectionString: PromiseLike<MySql.ConnectionConfig>;\n\n    constructor(connectionString: MySql.ConnectionConfig | PromiseLike<MySql.ConnectionConfig>) {\n        this._connectionString = Promise.resolve(connectionString);\n    }\n\n    public beginTransaction(): Promise<void> {\n        return Promise.reject(new Error('Not implemented'));\n    }\n\n    public commitTransaction(): Promise<void> {\n        return Promise.reject(new Error('Not implemented'));\n    }\n\n    public rollbackTransaction(): Promise<void> {\n        return Promise.reject(new Error('Not implemented'));\n    }\n\n    public execute<U>(query: QueryRecordSet<U>): Promise<IRecordSet<U>>\n    public execute<U>(query: QueryStream<U>): Promise<IRecordSet<U>>\n    public execute<U>(work: (connection: MySql.Connection) => IRecordSet<U> | PromiseLike<IRecordSet<U>>): Promise<IRecordSet<U>>\n    public async execute<U>(executable: any): Promise<IRecordSet<U>> {\n        let connectionString = await this._connectionString, \n            connection: MySql.Connection;\n\n        connectionString.multipleStatements = true;\n\n        connection = MySql.createConnection(connectionString);\n        connection.config.queryFormat = (query, values) => {\n            if (!values) return query;\n\n            return query.replace(/\\@(\\w+)/g, (txt, key) => {\n                if (values.hasOwnProperty(key)) {\n                    return connection.escape(values[key]);\n                }\n                return txt;\n            });\n        };\n\n        await promisify(connection.connect.bind(connection))();\n\n        var promise: Promise<IRecordSet<U>>;\n        if (typeof executable == 'function') {\n            promise = Promise.resolve(executable(connection));\n        } else {\n            executable.connection = connection;\n            promise = executable;\n        }\n\n        // since queries has to be enqued before ending connection we got to run our promise now\n        let recordset = await promise;\n\n        // Every method you invoke on a connection is queued and executed in sequence.\n        // Closing the connection is done using end() which makes sure all remaining queries are executed before sending a quit packet to the mysql server.\n        connection.end();\n\n        return recordset;\n    }\n\n    // private promisfy<U>(scope: any, func: Function, ...parameters: Array<any>): Promise<U> {\n    //     return new Promise((resolve, reject) => {\n    //         try {\n    //             func.call(scope || this, ...parameters, (err) => {\n    //                 if (err) {\n    //                     reject(err);\n    //                 }\n    //                 else {\n    //                     resolve(Array.from(arguments).slice(1));\n    //                 }\n    //             })\n    //         } catch (ex) {\n    //             reject(ex);\n    //         }\n    //     })\n    // }\n}"]}