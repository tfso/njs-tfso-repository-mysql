{"version":3,"file":"connection.js","sourceRoot":"","sources":["../../src/db/connection.ts"],"names":[],"mappings":"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","sourcesContent":["import * as MySql from 'mysql';\n\nimport { Query } from 'tfso-repository/lib/repository/db/query';\nimport { IRecordSet, RecordSet } from 'tfso-repository/lib/repository/db/recordset';\n\nimport { QueryRecordSet } from './queryrecordset';\nimport { QueryStream } from './querystream';\n\nexport default class Connection {\n    private _connectionString: PromiseLike<MySql.ConnectionOptions>;\n\n    constructor(connectionString: MySql.ConnectionOptions | PromiseLike<MySql.ConnectionOptions>) {\n        this._connectionString = Promise.resolve(connectionString);\n    }\n\n    public beginTransaction(): Promise<void> {\n        return Promise.reject(new Error('Not implemented'));\n    }\n\n    public commitTransaction(): Promise<void> {\n        return Promise.reject(new Error('Not implemented'));\n    }\n\n    public rollbackTransaction(): Promise<void> {\n        return Promise.reject(new Error('Not implemented'));\n    }\n\n    public execute<U>(query: QueryRecordSet<U>): Promise<IRecordSet<U>>\n    public execute<U>(query: QueryStream<U>): Promise<IRecordSet<U>>\n    public execute<U>(work: (connection: MySql.Connection) => IRecordSet<U> | PromiseLike<IRecordSet<U>>): Promise<IRecordSet<U>>\n    public execute<U>(executable: any): Promise<U> {\n        return new Promise((resolve, reject) => {\n            try {\n                this._connectionString\n                    .then((connectionString) => {\n                        try {\n                            let connection: MySql.Connection;\n\n                            connectionString.multipleStatements = true;\n\n                            connection = MySql.createConnection(connectionString);\n                            connection.config.queryFormat = (query, values) => {\n                                if (!values) return query;\n\n                                return query.replace(/\\@(\\w+)/g, (txt, key) => {\n                                    if (values.hasOwnProperty(key)) {\n                                        return connection.escape(values[key]);\n                                    }\n                                    return txt;\n                                });\n                            };\n\n                            connection.connect(err => {\n                                if (err)\n                                    return reject(err);\n\n                                var promise: Promise<IRecordSet<U>>;\n                                if (typeof executable == 'function') {\n                                    promise = Promise.resolve(executable(connection));\n                                } else {\n                                    executable.connection = connection;\n                                    promise = executable;\n                                }\n\n                                // since queries has to be enqued before ending connection we got to run our promise now\n                                promise\n                                    .then(recordset => {\n                                        resolve(recordset);\n                                    })\n                                    .catch(err => {\n                                        reject(err);\n                                    });\n\n                                // Every method you invoke on a connection is queued and executed in sequence.\n                                // Closing the connection is done using end() which makes sure all remaining queries are executed before sending a quit packet to the mysql server.\n                                connection.end();\n                            });\n                        }\n                        catch (ex) {\n                            reject(ex);\n                        }\n                    }, (err) => {\n                        reject(err);\n                    });\n            }\n            catch (ex) {\n                reject(ex);\n            }\n        });\n    }\n\n    private promisfy<U>(scope: any, func: Function, ...parameters: Array<any>): Promise<U> {\n        return new Promise((resolve, reject) => {\n            try {\n                func.call(scope || this, ...parameters, (err) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(Array.from(arguments).slice(1));\n                    }\n                })\n            } catch (ex) {\n                reject(ex);\n            }\n        })\n    }\n}"]}